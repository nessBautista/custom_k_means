"""
Dataclasses for notebook parameter management.

This module defines the data structures for storing notebook parameters,
computed results, and complete snapshots. Follows the pattern from
custom_k_means/src/core/grid_search_results.py for consistency.
"""

from dataclasses import dataclass, asdict
from typing import Dict, Any, Optional
from datetime import datetime


@dataclass
class NotebookParameters:
    """
    Notebook input parameters from sliders and dropdowns.

    These are the user-configurable parameters that control
    the segmentation pipeline behavior.
    """

    # Image selection
    image_id: str
    """BSD500 image ID (e.g., '12074')."""

    # K-means parameters
    k_clusters: int
    """Number of clusters for k-means segmentation."""

    # Velocity method
    velocity_method: str
    """Velocity computation method: 'constant', 'curvature', 'curvature_skimage', 'color', 'edge'."""

    edge_stopping_method: Optional[str] = None
    """Edge-stopping method (only for curvature): 'research', 'gradient', 'combined'."""

    # Evolution parameters
    dt: float = 0.5
    """Time step for level set evolution."""

    n_iterations: int = 10
    """Number of evolution iterations."""

    velocity_strength: float = 1.0
    """Velocity field strength multiplier (for constant, color, edge methods)."""

    smoothing_param: float = 0.1
    """Smoothing parameter for curvature velocity computation."""

    # Scikit-image curvature parameters
    alpha: Optional[float] = None
    """Alpha parameter for scikit-image edge-stopping (only for curvature_skimage)."""

    sigma: Optional[float] = None
    """Sigma parameter for scikit-image gaussian blur (only for curvature_skimage)."""

    reinit_frequency: int = 5
    """Re-initialization frequency (every N iterations)."""

    # Silhouette extraction
    silhouette_method: str = "labels"
    """Silhouette extraction method: 'canny_edges', 'labels', 'convex_hull', 'find_contours'."""

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'NotebookParameters':
        """
        Create NotebookParameters from dictionary.

        Args:
            data: Dictionary containing parameter values

        Returns:
            NotebookParameters instance
        """
        return cls(
            image_id=data.get('image_id', ''),
            k_clusters=data.get('k_clusters', 5),
            velocity_method=data.get('velocity_method', 'curvature'),
            edge_stopping_method=data.get('edge_stopping_method'),
            dt=data.get('dt', 0.5),
            n_iterations=data.get('n_iterations', 10),
            velocity_strength=data.get('velocity_strength', 1.0),
            smoothing_param=data.get('smoothing_param', 0.1),
            alpha=data.get('alpha'),
            sigma=data.get('sigma'),
            reinit_frequency=data.get('reinit_frequency', 5),
            silhouette_method=data.get('silhouette_method', 'labels')
        )

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert to dictionary for JSON serialization.

        Returns:
            Dictionary representation
        """
        return asdict(self)


@dataclass
class NotebookResults:
    """
    Computed results from notebook execution.

    These are the outputs generated by running the pipeline with
    the given parameters.
    """

    # PRI evaluation
    pri_kmeans: Optional[float] = None
    """PRI score for K-means segmentation."""

    pri_evolved: Optional[float] = None
    """PRI score for evolved segmentation."""

    pri_improvement: Optional[float] = None
    """Absolute improvement: pri_evolved - pri_kmeans."""

    pri_improvement_pct: Optional[float] = None
    """Relative improvement percentage."""

    num_ground_truths: int = 0
    """Number of ground truth annotations used for PRI computation."""

    # Silhouette extraction metrics
    contour_count: int = 0
    """Number of contours extracted."""

    foreground_ratio: float = 0.0
    """Ratio of foreground pixels (0-1)."""

    extraction_time_ms: float = 0.0
    """Silhouette extraction time in milliseconds."""

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'NotebookResults':
        """
        Create NotebookResults from dictionary.

        Args:
            data: Dictionary containing result values

        Returns:
            NotebookResults instance
        """
        return cls(
            pri_kmeans=data.get('pri_kmeans'),
            pri_evolved=data.get('pri_evolved'),
            pri_improvement=data.get('pri_improvement'),
            pri_improvement_pct=data.get('pri_improvement_pct'),
            num_ground_truths=data.get('num_ground_truths', 0),
            contour_count=data.get('contour_count', 0),
            foreground_ratio=data.get('foreground_ratio', 0.0),
            extraction_time_ms=data.get('extraction_time_ms', 0.0)
        )

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert to dictionary for JSON serialization.

        Returns:
            Dictionary representation
        """
        return asdict(self)


@dataclass
class NotebookSnapshot:
    """
    Complete snapshot of notebook state.

    Combines parameters, results, and metadata into a single
    structure for saving/loading.
    """

    metadata: Dict[str, Any]
    """Metadata: image_id, timestamp, description, etc."""

    parameters: NotebookParameters
    """Input parameters from notebook."""

    results: NotebookResults
    """Computed results from pipeline execution."""

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'NotebookSnapshot':
        """
        Create NotebookSnapshot from dictionary.

        Args:
            data: Dictionary containing complete snapshot

        Returns:
            NotebookSnapshot instance
        """
        return cls(
            metadata=data.get('metadata', {}),
            parameters=NotebookParameters.from_dict(data.get('parameters', {})),
            results=NotebookResults.from_dict(data.get('results', {}))
        )

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert to dictionary for JSON serialization.

        Returns:
            Dictionary representation with nested structures
        """
        return {
            'metadata': self.metadata,
            'parameters': self.parameters.to_dict(),
            'results': self.results.to_dict()
        }

    def __str__(self) -> str:
        """String representation for display."""
        img_id = self.metadata.get('image_id', 'unknown')
        timestamp = self.metadata.get('timestamp', 'unknown')
        pri_evolved = self.results.pri_evolved
        pri_str = f"{pri_evolved:.4f}" if pri_evolved is not None else "N/A"

        return (
            f"NotebookSnapshot(image={img_id}, "
            f"timestamp={timestamp}, "
            f"k={self.parameters.k_clusters}, "
            f"method={self.parameters.velocity_method}, "
            f"PRI={pri_str})"
        )
